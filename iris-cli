#!/bin/bash

VERSION="1.1.0"
AUTHOR="IrisWeb"
DEBUG=false

# Couleurs et styles
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
UNDERLINE='\033[4m'
NC='\033[0m'

USER_AGENT="Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36"
BASE_URL="https://www.neko-sama.to"

# Fonctions d'affichage

error() {
    printf "${RED}❌ Erreur: %s${NC}\n" "$1" >&2
}

success() {
    printf "${GREEN}✓ %s${NC}\n" "$1"
}

info() {
    printf "${BLUE}ℹ %s${NC}\n" "$1"
}

warning() {
    printf "${YELLOW}⚠ %s${NC}\n" "$1"
}

debug_log() {
    if [ "$DEBUG" = true ]; then
        printf "${DIM}[DEBUG] %s${NC}\n" "$1" >&2
    fi
}

center_text() {
    local text="$1"
    local width
    width=$(tput cols)
    local clean_text
    clean_text=$(echo -e "$text" | sed 's/\x1b\[[0-9;]*m//g')
    local text_length=${#clean_text}
    local padding=$(( (width - text_length) / 2 ))
    if (( padding > 0 )); then
        printf "%*s%s\n" "$padding" "" "$text"
    else
        echo -e "$text"
    fi
}

show_banner() {
    clear
    echo -e "${CYAN}"
    center_text "██╗██████╗ ██╗███████╗          ██████╗██╗     ██╗"
    center_text "██║██╔══██╗██║██╔════╝         ██╔════╝██║     ██║"
    center_text "██║██████╔╝██║███████╗ ║█████╗ ██║     ██║     ██║"
    center_text "██║██╔══██╗██║╚════██║ ╚════╝  ██║     ██║     ██║"
    center_text "██║██║  ██║██║███████║         ╚██████╗███████╗██║"
    center_text "╚═╝╚═╝  ╚═╝╚═╝╚══════╝          ╚═════╝╚══════╝╚═╝"
    echo -e "${NC}"
    center_text "${YELLOW}Version: ${VERSION} - Créé par ${AUTHOR}${NC}"
    center_text "${BLUE}Un lecteur vidéo en ligne de commande pour regarder des animes en VOSTFR et VF${NC}"
    center_text "${BLUE}Basé sur Ani-Cli${NC}\n"
}

show_help() {
    center_text "${BOLD}${UNDERLINE}Utilisation:${NC}"
    center_text "${CYAN}./iris-cli [options] [nom_anime] [numéro_episode]${NC}"
    echo
    center_text "${BOLD}${UNDERLINE}Options:${NC}"
    center_text "${YELLOW}-h, --help     ${NC}Affiche ce message d'aide"
    center_text "${YELLOW}-v, --version  ${NC}Affiche la version"
    center_text "${YELLOW}-d, --debug    ${NC}Active le mode debug"
    echo
    center_text "${BOLD}${UNDERLINE}Exemples:${NC}"
    center_text "${CYAN}./iris-cli \"One Piece\"          ${NC}# Recherche One Piece"
    center_text "${CYAN}./iris-cli \"Death Note\" 1      ${NC}# Lance l'épisode 1 de Death Note"
    center_text "${CYAN}./iris-cli -d \"One Piece\"      ${NC}# Lance en mode debug"
}

# Vérifie si sudo est disponible et demande les droits si nécessaire
check_sudo() {
    if [ "$EUID" -ne 0 ]; then
        if ! command -v sudo >/dev/null 2>&1; then
            error "sudo n'est pas installé. Veuillez l'installer manuellement."
            exit 1
        fi
        info "Ce script nécessite les privilèges root pour installer les dépendances."
        info "Veuillez entrer votre mot de passe sudo si demandé."
        sudo -v || { error "Échec de l'élévation des privilèges sudo."; exit 1; }
    fi
}

# Installation des dépendances sous Arch Linux uniquement
install_dependencies() {
    local missing_deps=()
    local system_deps=(curl grep sed awk mpv)
    local python_deps=(youtube-dl)
    
    info "Vérification des dépendances système..."
    for dep in "${system_deps[@]}"; do
        if ! command -v "$dep" >/dev/null 2>&1; then
            missing_deps+=("$dep")
        fi
    done
    
    if [ ${#missing_deps[@]} -gt 0 ]; then
        info "Dépendances système manquantes détectées: ${missing_deps[*]}"
        check_sudo
        info "Installation des dépendances manquantes via pacman..."
        sudo pacman -Sy --needed --noconfirm "${missing_deps[@]}" || {
            error "Échec de l'installation des dépendances système."
            exit 1
        }
        success "Dépendances système installées avec succès."
    else
        success "Toutes les dépendances système sont installées."
    fi
    
    # Installation python deps via pip si absentes
    for pdep in "${python_deps[@]}"; do
        if ! command -v "$pdep" >/dev/null 2>&1; then
            info "Installation de la dépendance Python $pdep via pip..."
            if ! pip install --user "$pdep"; then
                error "Échec de l'installation de $pdep via pip."
                exit 1
            fi
            success "$pdep installé avec succès."
        else
            debug_log "$pdep est déjà installé."
        fi
    done
}

# Encode une chaîne pour URL (simple)
url_encode() {
    local string="$1"
    # Remplacement simple espaces et caractères non alphanumériques
    echo -n "$string" | jq -sRr @uri
}

# Extraction numéro d'épisode dans un titre (ex: "Episode 12")
extract_episode_number() {
    local title="$1"
    echo "$title" | grep -oP '(?<=Episode )\d+' || echo ""
}

# Tri des épisodes par numéro
sort_episodes() {
    local episodes="$1"
    echo "$episodes" | while read -r line; do
        if [ -n "$line" ]; then
            num=$(extract_episode_number "$line")
            printf "%04d|%s\n" "$num" "$line"
        fi
    done | sort -n | cut -d'|' -f2-
}

# Affichage de la barre de progression
show_progress() {
    local current=$1
    local total=$2
    local width=50
    local progress=$((current * width / total))
    local bar=""
    for ((i=0; i<width; i++)); do
        if [ $i -lt $progress ]; then
            bar+="█"
        else
            bar+="░"
        fi
    done
    center_text "${YELLOW}Chargement: [${bar}] $((current * 100 / total))%${NC}"
}

# Récupération URL embed depuis page vidéo
get_embed_url() {
    local page_url="$1"
    # Extraire l'ID dans URL (exemple: vid=xxx)
    local video_id
    video_id=$(echo "$page_url" | grep -oP '[^_/]+(?=\.html)' || echo "")
    if [ -z "$video_id" ]; then
        error "Impossible d'extraire l'ID vidéo depuis l'URL."
        return 1
    fi
    echo "${BASE_URL}/embed.php?vid=${video_id}"
}

# Extraction URL vidéo et type (uqload ou sibnet)
get_video_url() {
    local embed_url="$1"
    debug_log "Extraction URL vidéo depuis: $embed_url"
    
    local embed_page
    embed_page=$(curl -s -A "$USER_AGENT" "$embed_url") || {
        error "Échec du téléchargement de la page d'embed."
        return 1
    }
    
    local iframe_url
    iframe_url=$(echo "$embed_page" | grep -oP '<iframe[^>]+src="\K[^"]+') || ""
    if [ -z "$iframe_url" ]; then
        error "Iframe non trouvée dans la page d'embed."
        return 1
    fi
    
    # Detecter hébergeur
    if echo "$iframe_url" | grep -q "uqload"; then
        echo "uqload|$iframe_url"
    elif echo "$iframe_url" | grep -q "sibnet"; then
        echo "sibnet|$iframe_url"
    else
        error "Hébergeur vidéo non supporté : $iframe_url"
        return 1
    fi
}

# Télécharger vidéo depuis uqload
download_uqload() {
    local url="$1"
    local output="$2"
    debug_log "Téléchargement uqload: $url"
    # Commande simulée, à adapter si tu as un vrai lien direct
    youtube-dl -o "$output" "$url" || return 1
}

# Télécharger vidéo depuis sibnet
download_sibnet() {
    local url="$1"
    local output="$2"
    debug_log "Téléchargement sibnet: $url"
    # Commande simulée, à adapter selon extraction réelle
    youtube-dl -o "$output" "$url" || return 1
}

# Extraction des épisodes (titre et url)
extract_episodes() {
    local anime_name="$1"
    local page=1
    local episodes=()
    
    local query=$(url_encode "$anime_name")
    
    while true; do
        local url="${BASE_URL}/animes/${query}/page/${page}"
        debug_log "Récupération de la page ${page}: $url"
        
        local page_content
        page_content=$(curl -s -A "$USER_AGENT" "$url")
        if [ -z "$page_content" ]; then
            warning "Page vide ou inaccessible: $url"
            break
        fi
        
        # Extraire titres et liens
        # Le pattern HTML est à ajuster selon site (exemple générique)
        mapfile -t page_episodes < <(echo "$page_content" | grep -Po '<a href="([^"]+)"[^>]*title="([^"]+)"' | sed -E 's/^<a href="([^"]+)"[^>]*title="([^"]+)".*$/\2|\1/')
        if [ ${#page_episodes[@]} -eq 0 ]; then
            debug_log "Aucun épisode trouvé à la page $page."
            break
        fi
        
        episodes+=("${page_episodes[@]}")
        
        # Si moins de 20 épisodes sur la page, fin de la pagination (arbitraire)
        if [ ${#page_episodes[@]} -lt 20 ]; then
            break
        fi
        
        ((page++))
    done
    
    # Supprimer doublons et trier
    episodes_unique=($(printf "%s\n" "${episodes[@]}" | sort -u))
    
    # Affichage trié
    printf "%s\n" "${episodes_unique[@]}"
}

# Menu de sélection épisode
select_episode() {
    local episodes=("$@")
    echo
    echo -e "${BOLD}Liste des épisodes disponibles :${NC}"
    local i=1
    for ep in "${episodes[@]}"; do
        local title="${ep%%|*}"
        local url="${ep#*|}"
        echo "[$i] $title"
        ((i++))
    done
    echo
    
    local choice
    while true; do
        read -rp "Sélectionnez un épisode (1-${#episodes[@]}): " choice
        if [[ "$choice" =~ ^[0-9]+$ ]] && (( choice >= 1 && choice <= ${#episodes[@]} )); then
            break
        else
            echo "Choix invalide, réessayez."
        fi
    done
    
    echo "${episodes[$((choice-1))]}"
}

# Lecture vidéo via mpv
play_video() {
    local video_url="$1"
    debug_log "Lancement de la lecture vidéo avec mpv: $video_url"
    mpv --force-window=immediate --no-terminal "$video_url"
}

# Nettoyage fichiers temporaires
cleanup() {
    if [ -n "$TMP_VIDEO" ] && [ -f "$TMP_VIDEO" ]; then
        rm -f "$TMP_VIDEO"
    fi
}
trap cleanup EXIT

# Traitement des arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case "$1" in
            -h|--help)
                show_banner
                show_help
                exit 0
                ;;
            -v|--version)
                echo "iris-cli version $VERSION"
                exit 0
                ;;
            -d|--debug)
                DEBUG=true
                shift
                ;;
            -*)
                error "Option inconnue : $1"
                exit 1
                ;;
            *)
                # Arguments positionnels
                POSITIONAL_ARGS+=("$1")
                shift
                ;;
        esac
    done
    set -- "${POSITIONAL_ARGS[@]}"
    ANIME_NAME="${POSITIONAL_ARGS[0]}"
    EPISODE_NUM="${POSITIONAL_ARGS[1]}"
    
    if [ -z "$ANIME_NAME" ]; then
        error "Veuillez spécifier le nom de l'anime."
        show_help
        exit 1
    fi
}

# --- SCRIPT PRINCIPAL ---

POSITIONAL_ARGS=()
parse_args "$@"
install_dependencies
show_banner

info "Recherche de l'anime: ${BOLD}${ANIME_NAME}${NC}"
episodes_list=()
mapfile -t episodes_list < <(extract_episodes "$ANIME_NAME")

if [ ${#episodes_list[@]} -eq 0 ]; then
    error "Aucun épisode trouvé pour '$ANIME_NAME'."
    exit 1
fi

selected_episode=""

if [ -n "$EPISODE_NUM" ]; then
    debug_log "Recherche épisode numéro $EPISODE_NUM"
    # Recherche épisode exact
    for ep in "${episodes_list[@]}"; do
        ep_title="${ep%%|*}"
        ep_url="${ep#*|}"
        ep_num=$(extract_episode_number "$ep_title")
        if [ "$ep_num" = "$EPISODE_NUM" ]; then
            selected_episode="$ep"
            break
        fi
    done
    if [ -z "$selected_episode" ]; then
        warning "Épisode $EPISODE_NUM non trouvé. Veuillez sélectionner manuellement."
    fi
fi

if [ -z "$selected_episode" ]; then
    selected_episode=$(select_episode "${episodes_list[@]}")
fi

episode_title="${selected_episode%%|*}"
episode_url="${selected_episode#*|}"

success "Épisode sélectionné : $episode_title"
info "URL : $episode_url"

embed_url=$(get_embed_url "$episode_url") || exit 1
read -r host video_iframe_url < <(get_video_url "$embed_url" | tr '|' ' ') || exit 1

TMP_VIDEO="/tmp/iriscli_video_$(date +%s).mp4"

case "$host" in
    uqload)
        info "Téléchargement depuis Uqload..."
        download_uqload "$video_iframe_url" "$TMP_VIDEO" || { error "Échec téléchargement."; exit 1; }
        ;;
    sibnet)
        info "Téléchargement depuis Sibnet..."
        download_sibnet "$video_iframe_url" "$TMP_VIDEO" || { error "Échec téléchargement."; exit 1; }
        ;;
    *)
        error "Hébergeur non supporté : $host"
        exit 1
        ;;
esac

play_video "$TMP_VIDEO"
